
import re
import sys
import logging
from io import StringIO
from .concolic_types.concolic_type import * 
from .concolic_types.concolic_str import * 
from .concolic_types.concolic_int import * 

SUPPORTED = [
    "ANY", 
    "AT",
    "BRANCH",
    "CATEGORY",
    "IN",
    "LITERAL",
    "RANGE",
    "SUBPATTERN",
    "MIN_REPEAT", 
    "MAX_REPEAT"

    """
    "FAILURE", 
    "SUCCESS",
    "ANY_ALL",
    "ASSERT", 
    "ASSERT_NOT",
    "CALL",
    "CHARSET", 
    "BIGCHARSET",
    "GROUPREF", 
    "GROUPREF_EXISTS",
    "INFO",
    "JUMP",
    "MARK",
    "MAX_UNTIL",
    "MIN_UNTIL",
    "NOT_LITERAL",
    "NEGATE",
    "REPEAT",
    "REPEAT_ONE",
    "MIN_REPEAT_ONE",

    "GROUPREF_IGNORE",
    "IN_IGNORE",
    "LITERAL_IGNORE",
    "NOT_LITERAL_IGNORE",

    "GROUPREF_LOC_IGNORE",
    "IN_LOC_IGNORE",
    "LITERAL_LOC_IGNORE",
    "NOT_LITERAL_LOC_IGNORE",

    "GROUPREF_UNI_IGNORE",
    "IN_UNI_IGNORE",
    "LITERAL_UNI_IGNORE",
    "NOT_LITERAL_UNI_IGNORE",
    "RANGE_UNI_IGNORE",
    """
]
"""
Categories:
    \d CATEGORY_DIGIT 
    \D CATEGORY_NOT_DIGIT
    \s CATEGORY_SPACE 
    \S CATEGORY_NOT_SPACE
    \w CATEGORY_WORD 
    \W CATEGORY_NOT_WORD
    CATEGORY_LINEBREAK CATEGORY_NOT_LINEBREAK

    CATEGORY_LOC_WORD CATEGORY_LOC_NOT_WORD

    \d CATEGORY_UNI_DIGIT 
    \D CATEGORY_UNI_NOT_DIGIT
    \s CATEGORY_UNI_SPACE 
    \S CATEGORY_UNI_NOT_SPACE
    \w CATEGORY_UNI_WORD 
    \W CATEGORY_UNI_NOT_WORD
    CATEGORY_UNI_LINEBREAK 
    CATEGORY_UNI_NOT_LINEBREAK
"""

log = logging.getLogger("ct.regex")

class PatternNode:
    def __init__(self, statement=None):
        self.statement = statement
        self.is_head = False
        self.is_end = False
        self.children = []

    def __str__(self):
        statement = self.statement
        if self.is_end:
            statement = "E " + statement
        if self.is_head:
            statement = "H " + statement
        if len(self.children) != 0:
            return "(%s: %s)" % (statement, ",".join(val.__str__() for val in self.children))
        else:
            return "(%s)" % statement

class RegexPattern:
    def __init__(self):
        # pattern object generated by re.compile
        self.pattern_value = None

        # A list of PatternNode
        self.pattern_nodes = None

        # Cache smt formula by method 'match', 'search', 'etc'
        self.re_expr = dict()

        self.can_do = True
        self.compiled = False

    def compile(self, pattern, flags=None): 
        if flags is not None:
            flags = flags | re.DEBUG
        else:
            flags = re.DEBUG

        # Capture the debug meg 
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result

        self.pattern_value = re.compile(pattern.value, flags)

        sys.stdout = old_stdout
        self._compile(result.getvalue())
        self.compiled = True

        return self

    def match(self, string, flags=None):
        if not self.compiled:
            self.compile(self.pattern_value, flags)

        formula = self.gen_formula("match")

        if isinstance(string, ConcolicStr):
            concolic_value = self.pattern_value.match(string.value)
        else:
            concolic_value = self.pattern_value.match(string)
        if concolic_value:
            return RegexMatch(formula, concolic_value)
        else:
            return ConcolicType("nil", None)

    def search(self, string, flags=None):
        if not self.compiled:
            self.compile(self.pattern_value, flags)

        formula = self.gen_formula("search")

        if isinstance(string, ConcolicStr):
            concolic_value = self.pattern_value.search(string.value)
        else:
            concolic_value = self.pattern_value.search(string)
        if concolic_value:
            return RegexMatch(formula, concolic_value)
        else:
            return ConcolicType("nil", None)

    def fullmatch(self, string, flags=None):
        if not self.compiled:
            self.compile(self.pattern_value, flags)

        formula = self.gen_formula("fullmatch")

        if isinstance(string, ConcolicStr):
            concolic_value = self.pattern_value.fullmatch(string.value)
        else:
            concolic_value = self.pattern_value.fullmatch(string)
        if concolic_value:
            return RegexMatch(formula, concolic_value)
        else:
            return ConcolicType("nil", None)




    def gen_formula(self, method="match"):
        if method in self.re_expr:
            return self.re_expr[method]
        formula = self._gen_formula(self.pattern_nodes, method)
        self.re_expr[method] = formula
        return formula

    def _gen_formula(self, pattern_nodes, method, is_union=False):
        expressions = []
        literal = None 

        for node in pattern_nodes:
            statement = node.statement
            op = statement.lstrip(' ').split(" ", 1)[0]

            # Handle head first
            if method != "core" and node.is_head:
                if op != "IN":
                    value = statement.split(" ")[1]
                if not (op == "AT" and value == "AT_BEGINNING"):
                    if method == "search":
                        expressions.append("(re.* re.allchar)")

            # Handle literal first
            if op != "LITERAL":
                if literal is not None:
                    expressions.append("(str.to.re \"%s\")" % literal)
                    literal = None

            # Main case handle
            if op == "FAILURE":
                # TODO
                log.warning("Regex %s Not implemented" % op)

            elif op == "SUCCESS":
                # TODO
                log.warning("Regex %s Not implemented" % op)
                
            elif op == "ANY":
                # TODO: Should be discarding '\n' ?
                expr = "re.allchar"
                expressions.append(expr)

            elif op == "AT":
                # Do nothing
                continue

            elif op == "BRANCH":
                branch_re = None
                child = node.children[0]
                branch_re = self._gen_formula(child.children, method)
                for index in range(1, len(node.children)):
                    or_re = self._gen_formula(node.children[index].children, method)
                    if branch_re is None:
                        branch_re = or_re
                    else:
                        branch_re = "(re.union %s %s)" % (branch_re, or_re)
                expressions.append(branch_re)

            elif op == "IN":
                expr = self._gen_formula(node.children, method, True)
                expressions.append(expr)

            elif op == "LITERAL":
                char = statement.split(" ")[1]
                if is_union:
                    expressions.append("(str.to.re \"%s\")" % chr(int(char)))
                else:
                    if literal is None:
                        literal = chr(int(char))
                    else:
                        literal += chr(int(char))

            elif op == "RANGE":
                var = statement.split(" ", 1)[1].replace("(", "").replace(")", "")
                low, high = var.split(", ")
                expr = "(re.range \"%s\" \"%s\")" % (chr(int(low)), chr(int(high)))
                expressions.append(expr)

            elif op == "SUBPATTERN":
                inner = self._gen_formula(node.children, method)
                if inner is not None:
                    expressions.append(inner)

            elif op == "CATEGORY":
                category = statement.split(" ")[1]
                if category == "CATEGORY_DIGIT":
                    expr = "(re.range \"0\" \"9\")"
                elif category == "CATEGORY_NOT_DIGIT":
                    # Before '0'(\x30)
                    expr0 = "(re.range \"\\x00\" \"\\x2f\")"
                    # After '9'(\x39), before end(\xff)
                    expr1 = "(re.range \"\\x3a\" \"\\xff\")"
                    expr = "(re.union %s %s)" % (expr0, expr1)
                elif category == "CATEGORY_SPACE":
                    expr = "(re.range \"\\t\" \"\\r\")"
                elif category == "CATEGORY_NOT_SPACE":
                    # Before '\t'(\x30)
                    expr0 = "(re.range \"\\x00\" \"\\x09\")"
                    # After '\r'(\x0d), before end(\xff)
                    expr1 = "(re.range \"\\x0d\" \"\\xff\")"
                    expr = "(re.union %s %s)" % (expr0, expr1)
                elif category == "CATEGORY_WORD":
                    exprd = "(re.range \"0\" \"9\")"
                    expra = "(re.range \"a\" \"z\")"
                    exprA = "(re.range \"A\" \"Z\")"
                    expr = "(re.union %s (re.union %s %s))" % (exprd, expra, exprA)
                elif category == "CATEGORY_NOT_WORD":
                    # Before '0'(\x30)
                    expr0 = "(re.range \"\\x00\" \"\\x2f\")"
                    # After '9'(\x39), before 'A'(\x41)
                    expr1 = "(re.range \"\\x3a\" \"\\x40\")"
                    # After 'Z'(\x5a), before 'a'(\x61)
                    expr2 = "(re.range \"\\x5b\" \"\\x60\")"
                    # After 'z'(\x7a), before end(\xff)
                    expr3 = "(re.range \"\\x7a\" \"\\xff\")"
                    expr = "(re.union (re.union %s %s) (re.union %s %s))" % (expr0, expr1, expr2, expr3)
                else:
                    print("Not handling CATEGORY with: %s" % category)
                    exit()
                expressions.append(expr)

            elif op == "MAX_REPEAT" or op == "MIN_REPEAT" :
                # TODO: I assume they are the same
                _, start, end = statement.split(" ")
                inner = self._gen_formula(node.children, method)
                if not start.isdigit():
                    print("Not handling REPEAT with: %s" % start)
                    exit(1)
                else:
                    start = int(start)
                if end == "MAXREPEAT":
                    if start == 0:
                        expr = "(re.* %s)" % inner
                    elif start == 1:
                        expr = "(re.+ %s)" % inner
                    else:
                        expr = "(re.loop %s %s %s)" % (inner, start, MAXREPEAT)
                else:
                    expr = "(re.loop %s %s %s)" % (inner, start, end)
                expressions.append(expr)

            else:
                # TODO
                log.warning("Regex %s Not implemented" % op)


        if literal is not None:
            expressions.append("(str.to.re \"%s\")" % literal)

        if node.is_end:
            if op != "IN":
                value = statement.split(" ")[1]
            if not (op == "AT" and value == "AT_END"):
                if method != "core" or method != "fullmatch":
                    expressions.append("(re.* re.allchar)")

        # Concat the nodes
        if is_union:
            ret = None
            if len(expressions) == 1:
                return expressions[0]
            elif len(expressions) > 1:
                ret = expressions[0]
                for index in range(1, len(expressions)):
                    if ret is None:
                        ret = expressions[index]
                    else:
                        ret = "(re.union %s %s)" % (ret, expressions[index])
                return ret
            else:
                return None

        if len(expressions) == 1:
            return expressions[0]
        elif len(expressions) > 1:
            ret = "(re.++"
            for expr in expressions:
                ret += " "
                ret += expr
            ret += ")"
            return ret
        else:
            return None

    def _parse2_nodes(self, lines, line_no, leading_space):
        statements = []
        while line_no < len(lines):
            line = lines[line_no]
            leading = len(line) - len(line.lstrip(' '))

            op = line.lstrip(' ').split(" ", 1)[0]
            if op not in SUPPORTED:
                self.can_do = False
            
            if leading == leading_space:
                node = PatternNode(line.lstrip(' '))
                statements.append(node)
                line_no += 1
            elif leading < leading_space:
                return statements, line_no
            else:
                sts, line_no = self._parse2_nodes(lines, line_no, leading)
                t_node = statements[-1]
                op = t_node.statement.split(" ", 1)[0]
                if op == "BRANCH":
                    n_node = PatternNode("BRANCH_c")
                    n_node.children = sts
                    t_node.children.append(n_node)
                elif op == "OR":
                    statements.pop(-1)
                    n_node = PatternNode("BRANCH_c")
                    n_node.children = sts
                    statements[-1].children.append(n_node)
                else:
                    statements[-1].children = sts
        return statements, line_no

    def _simplify_node(self, p_node):
        op = p_node.statement.split(" ", 1)[0]
        if op == "IN" or op == "SUBPATTERN":
            if len(p_node.children) == 1:
                child = p_node.children[0]
                p_node.statement = child.statement
                p_node.children = child.children

        for node in p_node.children:
            node = self._simplify_node(node)

        return p_node

    def _set_head_end(self, node, flag):
        op = node.statement.split(" ", 1)[0]
        if node.children is not None and len(node.children) != 0:
            if op == "BRANCH":
                for child in node.children:
                    self._set_head_end(child, flag)
            elif op == "IN":
                if flag == 0:
                    node.is_head = True
                else:
                    node.is_end = True
            else:
                self._set_head_end(node.children[flag], flag)
        else:
            if flag == 0:
                node.is_head = True
            else:
                node.is_end = True


    def _compile(self, raw):
        lines = []
        # Discard the 2nd part of DEBUG meg
        for line in raw.splitlines():
            if len(line) == 0:
                break
            else:
                lines.append(line)
                log.debug("Debug:   %s" % line)

        self.pattern_nodes, _ = self._parse2_nodes(lines, 0, 0)

        for node in self.pattern_nodes:
            node = self._simplify_node(node)

        self._set_head_end(self.pattern_nodes[0], 0)
        self._set_head_end(self.pattern_nodes[-1], -1)

        log.debug("Compiled: %s" % self._gen_formula(self.pattern_nodes, "match"))


    # Overwrite area
    def __str__(self):
        return "{Pattern, pattern: %s)" % ",".join(val.__str__() for val in self.pattern_nodes) 


class RegexWrap():
    def __init__(self):
        self.pattern = RegexPattern()

    def match(self, pattern, string, flags=None):
        self.pattern.compile(pattern, flags)
        return self.pattern.match(string)

    def search(self, pattern, string, flags=None):
        self.pattern.compile(pattern, flags)
        return self.pattern.search(string)

    def fullmatch(self, pattern, string, flags=None):
        self.pattern.compile(pattern, flags)
        return self.pattern.fullmatch(string)


class RegexMatch():
    def __init__(self, expr, value):
        self.expr = expr
        self.value = value


    def group(self, index=0):
        if isinstance(index, ConcolicInteger):
            index = index.value
        value = self.value[index]
        return ConcolicStr('\"' + value + '\"', value)

    # Overwrite area
    def __str__(self):
        return "{Match, expr: %s)" % self.expr

    def __getitem__(self, g):
        return self.group(g)

